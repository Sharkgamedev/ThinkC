% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey
% Copyright (C) 2009  Thomas Scheffler
% Copyright (C) 2023 Michael K Penta

\chapter{Working with files}
\label{files}
\index{files}


\section{Introduction}
File handling is a fundamental aspect of programming, allowing us to store and retrieve
data that can be used across multiple runs of a program. In C programming, file handling
is achieved using the stdio.h library, which provides a variety of functions for reading
from and writing to files. In this chapter, we will explore the basics of file handling
in C, including opening and closing files, reading and writing data to files, and
handling errors that may occur during file input/output.

\section{Text Files vs Binary Files}
Before diving into working with files in C, it is important to understand the differences
between text files and binary files. Text files are files that contain human-readable
text, such as plain text documents or CSV files. These files are composed of a series of
characters, usually encoded in ASCII or Unicode format. Binary files, on the other hand,
are files that contain machine-readable data, such as executable files or images. These
files are composed of a series of bytes that represent binary data and are not
human-readable.

The choice between text files and binary files depends on the type of data being stored
and the intended use of the file. Text files are usually used for storing data that can
be easily edited by humans, such as configuration files or log files. On the other hand,
binary files are typically used for storing data that is not easily editable by humans,
such as multimedia files or database files.

One of the key differences between text files and binary files is the way that they are
read and written. Text files can be read and written using standard functions such as
{\tt fgets()} and {\tt fprintf()}, while binary files require more specialized functions
such as {\tt fread()} and {\tt fwrite()}.

\section{Opening and Closing Files}
Once we have decided on the type of file we want to use, the next step is to open the
file. In C, we use the {\tt fopen()} function to open a file, which takes two parameters:
the name of the file to be opened and the mode in which it is to be opened. The mode
parameter specifies whether the file is to be opened for reading, writing, or both, as
well as whether the file is to be created if it does not exist.

There are several modes in which a file can be opened, including:
\begin{description}
\item[r]: Open file for reading
\item[w]: Open file for writing (overwrite if file already exists)
\item[a]: Open file for appending (write to end of file)
\item[r$+$]: Open file for both reading and writing
\item[w$+$]: Open file for both reading and writing (overwrite if file already exists)
\item[a$+$]: Open file for both reading and writing (write to end of file)
\end{description}
Once a file has been opened, we can perform operations on it, such as reading data from
or writing data to the file. When we are finished working with a file, it is important to
close it using the {\tt fclose()} function. This ensures that any changes made to the
file are saved and any resources used by the file are freed up.


\section{Reading from Text Files}
Imagine we have a text file called "students.txt" containing a list of students' names, one name per line. We want to read the data from this file and display it on the screen. The following example demonstrates how to read data from a text file using {\tt fgets()}:

\begin{verbatim}
	FILE *file = fopen("students.txt", "r");
	if (file != NULL) 
	{
		char name[256];
		printf("List of Students:\n");
		while (fgets(name, sizeof(name), file) != NULL) {
			printf("%s", name);
		}
		fclose(file);
	}
\end{verbatim}

\section{Writing to Text Files}
Suppose we want to create a text file called "grades.txt" to store the grades of students in a course. We have a struct called "Student" containing the student's name and grade. The following example demonstrates how to write data to a text file using {\tt fprintf()}:

\begin{verbatim}
	typedef struct 
	{
		char name[50];
		int grade;
	} Student;
	
	Student students[] =
	 {
		{"Alice", 85},
		{"Bob", 92},
		{"Carol", 78}
	};
	
	FILE *file = fopen("grades.txt", "w");
	if (file != NULL)
	 {
		for (int i = 0; i < 3; i++) 
		{
			fprintf(file, "Name: %s, Grade: %d\n", students[i].name, students[i].grade);
		}
		fclose(file);
	}
\end{verbatim}

\section{Reading from Binary Files}
Consider a binary file called "inventory.bin" containing a list of products in a store. 
Each product has a struct called "Product" containing a product ID and its stock quantity.
 The following example demonstrates how to read data from a binary file using {\tt fread()}:

\begin{verbatim}
	typedef struct 
	{
		int productID;
		int stock;
	} Product;
	
	FILE *file = fopen("inventory.bin", "rb");
	if (file != NULL)
	 {
		Product products[5];
		size_t read_elements = fread(products, sizeof(Product), 5, file);
		
		printf("Product Inventory:\n");
		for (int i = 0; i < read_elements; i++)
		{
			printf("Product ID: %d, Stock: %d\n", products[i].productID, products[i].stock);
		}
		
		fclose(file);
	}
\end{verbatim}

\section{Writing to Binary Files}
Suppose we want to create a binary file called "sales.bin" to store the sales data of a store. Each sale record has a struct called "Sale" containing a transaction ID, product ID, and quantity sold. The following example demonstrates how to write data to a binary file using {\tt fwrite()}:

\begin{verbatim}
	typedef struct {
		int transactionID;
		int productID;
		int quantity;
	} Sale;
	
	Sale sales[] =
	 {
		{1, 101, 5},
		{2, 102, 3},
		{3, 103, 8}
	};
	
	FILE *file = fopen("sales.bin", "wb");
	if (file != NULL) 
	{
		fwrite(sales, sizeof(Sale), 3, file);
		fclose(file);
	}
\end{verbatim}




\section{Finding the size of a file}

Sometimes we need to know the size of a file in bytes. We can use the {\tt fseek()} and {\tt ftell()} functions to accomplish this task. Here's an example of how to use these functions:

\begin{verbatim}
	#include <stdio.h>
	
	int main() {
		FILE *file = fopen("data.txt", "r");
		
		scss
		
		if (file == NULL) {
			printf("Error opening file.\n");
			return 1;
		}
		
		// seek to the end of the file
		fseek(file, 0, SEEK_END);
		
		// get the current position, which is the size of the file
		long size = ftell(file);
		
		printf("File size: %ld bytes.\n", size);
		
		fclose(file);
		return 0;
		
	}
\end{verbatim}

In this example, we first open the file "data.txt" for reading. Then we use {\tt fseek()} to seek to the end of the file. The second parameter to {\tt fseek()} specifies the offset from the origin, which is 0 in this case, and the third parameter specifies the origin, which is {\tt SEEK_END} to seek to the end of the file.

After seeking to the end of the file, we use {\tt ftell()} to get the current position in the file, which is the size of the file. We store this value in the variable {\tt size} and print it to the console.

It's worth noting that we can also use {\tt rewind()} to set the file position back to the beginning of the file. Here's an example:

\begin{verbatim}
	#include <stdio.h>
	
	int main() {
		FILE *file = fopen("data.txt", "r");
		
		scss
		
		if (file == NULL) {
			printf("Error opening file.\n");
			return 1;
		}
		
		// seek to the end of the file
		fseek(file, 0, SEEK_END);
		
		// get the current position, which is the size of the file
		long size = ftell(file);
		
		// set the position back to the beginning of the file
		rewind(file);
		
		// read the contents of the file
		char buffer[size + 1];
		fgets(buffer, size + 1, file);
		printf("File contents: %s", buffer);
		
		fclose(file);
		return 0;
		
	}
\end{verbatim}

In this example, we seek to the end of the file and get the file size using {\tt fseek()} and {\tt ftell()}, just like before. However, this time we use {\tt rewind()} to set the file position back to the beginning of the file. Then we read the contents of the file into a buffer using {\tt fgets()} and print it to the console.

\section{Common errors with files}

When working with files, it's important to handle errors that can occur. Some common errors include:

\begin{itemize}
	\item Failing to check if a file was successfully opened with {\tt fopen()}
	\item Failing to close a file with {\tt fclose()} when finished using it
	\item Attempting to read from or write to a file that is not open or does not exist
	\item Using incorrect file modes, such as trying to write to a file that was opened in read-only mode
	\item Not properly handling errors that can occur during file input/output operations
\end{itemize}

To avoid these errors, always check the return value of {\tt fopen()} to ensure that the file was successfully opened, and always close the file with {\tt fclose()} when finished using it.

\section{Glossary}

\begin{description}
	\item[File handling:] The process of reading from and writing to files in a program.
	\item[Text file:] A file that contains human-readable text, such as plain text documents or CSV files.
	\item[Binary file:] A file that contains machine-readable data, such as executable files or images.
	\item[ASCII:] A character encoding standard that represents each character as a unique 7-bit code.
	\item[Unicode:] A character encoding standard that represents each character as a unique 16-bit or 32-bit code.
	\item[Mode:] A parameter used when opening a file that specifies the intended use of the file (e.g. read, write, append).
	\item[Error handling:] The process of handling errors that may occur during file input/output.
	\item[File pointer:] A variable that points to a specific position in a file.
\end{description}

\section{Exercises}
\setcounter{exercisenum}{0}

\input{exercises/Exercise_9_english}


