% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey
% Copyright (C) 2009  Thomas Scheffler
% Copyright (C) 2023 Michael K Penta

\chapter{Working with files}
\label{files}
\index{files}


\section{Introduction}
File handling is a fundamental aspect of programming, allowing us to store and retrieve
data that can be used across multiple runs of a program. In C programming, file handling
is achieved using the stdio.h library, which provides a variety of functions for reading
from and writing to files. In this chapter, we will explore the basics of file handling
in C, including opening and closing files, reading and writing data to files, and
handling errors that may occur during file input/output.

\section{Text Files vs Binary Files}
Before diving into working with files in C, it is important to understand the differences
between text files and binary files. Text files are files that contain human-readable
text, such as plain text documents or CSV files. These files are composed of a series of
characters, usually encoded in ASCII or Unicode format. Binary files, on the other hand,
are files that contain machine-readable data, such as executable files or images. These
files are composed of a series of bytes that represent binary data and are not
human-readable.

The choice between text files and binary files depends on the type of data being stored
and the intended use of the file. Text files are usually used for storing data that can
be easily edited by humans, such as configuration files or log files. On the other hand,
binary files are typically used for storing data that is not easily editable by humans,
such as multimedia files or database files.

One of the key differences between text files and binary files is the way that they are
read and written. Text files can be read and written using standard functions such as
{\tt fgets()} and {\tt fprintf()}, while binary files require more specialized functions
such as {\tt fread()} and {\tt fwrite()}.

\section{Opening and Closing Files}
Once we have decided on the type of file we want to use, the next step is to open the
file. In C, we use the {\tt fopen()} function to open a file, which takes two parameters:
the name of the file to be opened and the mode in which it is to be opened. The mode
parameter specifies whether the file is to be opened for reading, writing, or both, as
well as whether the file is to be created if it does not exist.

There are several modes in which a file can be opened, including:
\begin{description}
\item[r]: Open file for reading
\item[w]: Open file for writing (overwrite if file already exists)
\item[a]: Open file for appending (write to end of file)
\item[r+]: Open file for both reading and writing
\item[w+]: Open file for both reading and writing (overwrite if file already exists)
\item[a+]: Open file for both reading and writing (write to end of file)
\end{description}
Once a file has been opened, we can perform operations on it, such as reading data from
or writing data to the file. When we are finished working with a file, it is important to
close it using the {\tt fclose()} function. This ensures that any changes made to the
file are saved and any resources used by the file are freed up.


\section{Reading from Text Files}
Imagine we have a text file called "students.txt" containing a list of students' names, one name per line. We want to read the data from this file and display it on the screen. The following example demonstrates how to read data from a text file using {\tt fgets()}:

\begin{verbatim}
	FILE *file = fopen("students.txt", "r");
	if (file != NULL) 
	{
		char name[256];
		printf("List of Students:\n");
		while (fgets(name, sizeof(name), file) != NULL) {
			printf("%s", name);
		}
		fclose(file);
	}
\end{verbatim}

\section{Writing to Text Files}
Suppose we want to create a text file called "grades.txt" to store the grades of students in a course. We have a struct called "Student" containing the student's name and grade. The following example demonstrates how to write data to a text file using {\tt fprintf()}:

\begin{verbatim}
	typedef struct 
	{
		char name[50];
		int grade;
	} Student;
	
	Student students[] =
	 {
		{"Alice", 85},
		{"Bob", 92},
		{"Carol", 78}
	};
	
	FILE *file = fopen("grades.txt", "w");
	if (file != NULL)
	 {
		for (int i = 0; i < 3; i++) 
		{
			fprintf(file, "Name: %s, Grade: %d\n", students[i].name, students[i].grade);
		}
		fclose(file);
	}
\end{verbatim}

\section{Reading from Binary Files}
Consider a binary file called "inventory.bin" containing a list of products in a store. 
Each product has a struct called "Product" containing a product ID and its stock quantity.
 The following example demonstrates how to read data from a binary file using {\tt fread()}:

\begin{verbatim}
	typedef struct 
	{
		int productID;
		int stock;
	} Product;
	
	FILE *file = fopen("inventory.bin", "rb");
	if (file != NULL)
	 {
		Product products[5];
		size_t read_elements = fread(products, sizeof(Product), 5, file);
		
		printf("Product Inventory:\n");
		for (int i = 0; i < read_elements; i++)
		{
			printf("Product ID: %d, Stock: %d\n", products[i].productID, products[i].stock);
		}
		
		fclose(file);
	}
\end{verbatim}

\section{Writing to Binary Files}
Suppose we want to create a binary file called "sales.bin" to store the sales data of a store. Each sale record has a struct called "Sale" containing a transaction ID, product ID, and quantity sold. The following example demonstrates how to write data to a binary file using {\tt fwrite()}:

\begin{verbatim}
	typedef struct {
		int transactionID;
		int productID;
		int quantity;
	} Sale;
	
	Sale sales[] =
	 {
		{1, 101, 5},
		{2, 102, 3},
		{3, 103, 8}
	};
	
	FILE *file = fopen("sales.bin", "wb");
	if (file != NULL) 
	{
		fwrite(sales, sizeof(Sale), 3, file);
		fclose(file);
	}
\end{verbatim}




\section{Glossary}

\begin{description}
	
	\item[structure:]  A collection of data grouped together and
	treated as a single object.
	
	\item[member variable:]  One of the named pieces of data that make up
	a structure.
	
	\item[reference:]  A value that indicates or refers to a variable
	or structure.  In a state diagram, a reference appears as an arrow.
	
	\item[pass by value:]  A method of parameter-passing in which the
	value provided as an argument is copied into the corresponding
	parameter, but the parameter and the argument occupy distinct
	locations.
	
	\item[pass by reference:]  A method of parameter-passing in which
	the parameter is a reference to the argument variable.  Changes
	to the parameter also affect the argument variable.
	
	\index{structure}
	\index{member variable}
	\index{reference}
	\index{pass by value}
	\index{pass by reference}
	
\end{description}

\section{Exercises}
\setcounter{exercisenum}{0}

\input{exercises/Exercise_9_english}


