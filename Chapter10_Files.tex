% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey
% Copyright (C) 2009  Thomas Scheffler
% Copyright (C) 2023 Michael K Penta

\chapter{Working with files}
\label{files}
\index{files}
	
	
	\section{Opening and Closing Files}
	
	Imagine you are writing a program to track a library's books. You would need to 
	read the data from a file containing a list of books and their information. In C, 
	we open the file using the {\tt fopen()} function, as shown in the following example:
	
	\begin{verbatim}
		FILE *file = fopen("books.txt", "r");
		if (file == NULL) {
			printf("Error: Unable to open file.\n");
			return 1;
		}
		
		// Perform operations on the file, such as reading the list of books
		
		fclose(file);
	\end{verbatim}
	
	In this example, we open a text file called "books.txt' in read mode ("r"). We then 
	check if the file was opened successfully. If the file pointer is NULL, it indicates 
	an error. After performing the necessary operations, we close the file using the 
	fclose() function.
	
	\section{Reading and Writing to Files}
	
	\subsection{Reading from Text Files}
	
	Suppose we have a text file called \emph{library_books.txt} containing a list of books 
	and their authors, separated by a comma. We want to read the data from this file 
	and display it on the screen. The following example demonstrates how to read data 
	from a text file using fgets():
	
	\begin{verbatim}
		FILE *file = fopen("library_books.txt", "r");
		if (file != NULL) {
			char line[256];
			printf("List of Books:\n");
			while (fgets(line, sizeof(line), file) != NULL) {
				printf("%s", line);
			}
			fclose(file);
		}
	\end{verbatim}
	
	\subsection{Writing to Text Files}
	
	Now, let's assume we want to create a new text file called "borrowed_books.txt" 
	to store the list of borrowed books and their due dates. We have an array of 
	structs called "BorrowedBook" containing the book title and the due date. The 
	following example demonstrates how to write data to a text file using fprintf():
	
	\begin{verbatim}
		typedef struct {
			char title[100];
			char due_date[11];
		} BorrowedBook;
		
		BorrowedBook borrowed_books[] = {
			{"The Catcher in the Rye", "2023-04-15"},
			{"To Kill a Mockingbird", "2023-04-20"},
			{"1984", "2023-04-25"}
		};
		
		FILE *file = fopen("borrowed_books.txt", "w");
		if (file != NULL) {
			for (int i = 0; i < 3; i++) {
				fprintf(file, "Title: %s, Due Date: %s\n", 
				borrowed_books[i].title, borrowed_books[i].due_date);
			}
			fclose(file);
		}
	\end{verbatim}
	
	These examples provide more context and real-world scenarios to help our students 
	better understand the file handling concepts in C. Maintaining this approach 
	throughout the book will ensure our students can apply the concepts in their own 
	programming projects.
	

















\section{Call by value}
\label{Call by value}
\index{parameter passing}
\index{call by value}

When you pass a structure as an argument, remember that the
argument and the parameter are not the same variable.  Instead,
there are two variables (one in the caller and one in the
callee) that have the same value, at least initially.  For
example, when we call {\tt PrintPoint()}, the stack diagram
looks like this:

\vspace{0.1in}
\centerline{\epsfig{figure=figs/stack_point2.pdf, width=6cm}}
\vspace{0.1in}
%
If {\tt PrintPoint()} happened to change one of the member variables
of {\tt point}, it would have no effect on {\tt blank}.  Of course, there
is no reason for {\tt PrintPoint()} to modify its parameter, so this
isolation between the two functions is appropriate.

This kind of parameter-passing is called ``pass by value''
because it is the value of the structure (or other type) that
gets passed to the function.

\section{Call by reference}
\label{Call by reference}
\index{parameter passing}
\index{call by reference}
\index{reference}

An alternative parameter-passing mechanism that is available
in C is called ``pass by reference.''  
By now we already know that C uses pointers as references.
This mechanism makes
it possible to pass a structure to a procedure and modify it directly.

For example, you can reflect a point around the 45-degree line by
swapping the two coordinates.  The most obvious (but incorrect) way to
write a {\tt ReflectPoint()} function is something like this:

\begin{verbatim}
	void ReflectPoint (Point_t point)      /* Does not work! */
	{
		double temp = point.x;
		point.x = point.y;
		point.y = temp;
	}
\end{verbatim}
%
This won't work, because the changes we make in {\tt ReflectPoint()}
will have no effect on the caller.

Instead, we have to specify that we want to pass the parameter by
reference.  
Our function now has a struct pointer argument {\tt Point\_t~*ptr}.


\begin{verbatim}
	void ReflectPoint (Point_t *ptr)
	{
		double temp = ptr->x;
		ptr->x = ptr->y;
		ptr->y = temp;
	}
\end{verbatim}
When we are accessing the struct member variables through a pointer 
we can no longer use the "field-selection-operator" ({\tt .}). Instead we need to use
the "pointing-to" operator ({\tt ->}).

%
We pass a reference of our struct parameter by adding the "address-of"  operator ({\tt \&}) to the
structure variable when we call the function:

\begin{verbatim}
	PrintPoint (blank);
	ReflectPoint (&blank);
	PrintPoint (blank);
\end{verbatim}
%
The output of this program is as expected:

\begin{verbatim}
	(3.0, 4.0)
	(4.0, 3.0)
\end{verbatim}
%
Here's how we would draw a stack diagram for this program:

\vspace{0.1in}
\centerline{\epsfig{figure=figs/stack_point3.pdf, width=6.5cm}}
\vspace{0.1in}
%
The parameter {\tt ptr} is a reference to the structure named {\tt
	blank}.  The usual representation for a reference is a dot with an
arrow that points to whatever the reference refers to.

The important thing to see in this diagram is that any changes that
{\tt ReflectPoint()} makes through {\tt ptr} will also affect {\tt blank}.

Passing structures by reference is more versatile than passing by
value, because the callee can modify the structure.  It is also
faster, because the system does not have to copy the whole
structure.  On the other hand, it is less safe, since it is harder to
keep track of what gets modified where.  Nevertheless, in C
programs, almost all structures are passed by reference almost all the
time.  In this book I will follow that convention.


\section{Rectangles}
\index{Rectangle}
\index{struct!Rectangle}

Now let's say that we want to create a structure to represent
a rectangle.  The question is, what information do I have to
provide in order to specify a rectangle?  To keep things simple
let's assume that the rectangle will be oriented vertically or
horizontally, never at an angle.

There are a few possibilities: I could specify the center of
the rectangle (two coordinates) and its size (width and height),
or I could specify one of the corners and the size, or I
could specify two opposing corners.

The most common choice in existing programs is to specify the
upper left corner of the rectangle and the size.  To do that
in C, we will define a structure that contains a {\tt Point\_t}
and two doubles.

\begin{verbatim}
	typedef struct 
	{
		Point_t corner;
		double width, height;
	} Rectangle_t;  
\end{verbatim}
%
Notice that one structure can contain another.  In fact, this
sort of thing is quite common.  Of course, this means that in
order to create a {\tt Rectangle\_t}, we have to create a {\tt Point\_t}
first:

\begin{verbatim}
	Point_t corner = { 0.0, 0.0 };
	Rectangle_t box = { corner, 100.0, 200.0 };
\end{verbatim}
%
This code creates a new {\tt Rectangle\_t} structure and initializes the
member variables.  The figure shows the effect of this assignment.

\vspace{0.1in}
\centerline{\epsfig{figure=figs/rectangle.pdf, width=6cm}}
\vspace{0.1in}
%
We can access the {\tt width} and {\tt height} in the usual way:

\begin{verbatim}
	box.width += 50.0;
	printf("%f\n", box.width);
\end{verbatim}
%
In order to access the member variables of {\tt corner}, we can use a
temporary variable:

\begin{verbatim}
	Point_t temp = box.corner;
	double x = temp.x;
\end{verbatim}
%
Alternatively, we can compose the two statements:

\index{composition}

\begin{verbatim}
	double x = box.corner.x;
\end{verbatim}
%
It makes the most sense to read this statement from right to
left: ``Extract {\tt x} from the {\tt corner} of the {\tt box},
and assign it to the local variable {\tt x}.''

While we are on the subject of composition, I should point
out that you can, in fact, create the {\tt Point} and the
{\tt Rectangle} at the same time:

\begin{verbatim}
	Rectangle_t box = { { 0.0, 0.0 }, 100.0, 200.0 };
\end{verbatim}
%
The innermost squiggly braces are the coordinates of the
corner point; together they make up the first of the three
values that go into the new {\tt Rectangle}.  This statement
is an example of {\bf nested structure}.

\index{nested structure}


\section{Structures as return types}
\index{struct!as return type}
\index{return}
\index{statement!return}

You can write functions that return structures.  For example,
{\tt FindCenter()} has a {\tt Rectangle\_t} parameter and
returns a {\tt Point\_t} that contains the coordinates of the
center of the rectangle:

\begin{verbatim}
	Point_t FindCenter (Rectangle_t box)
	{
		double x = box.corner.x + box.width/2;
		double y = box.corner.y + box.height/2;
		Point_t result = {x, y};
		return result;
	}
\end{verbatim}
%
To call this function, we have to pass a {\tt Rectangle\_t} as an argument
(notice that it is being passed by value), and assign the
return value to a {\tt Point\_t} variable:

\begin{verbatim}
	Rectangle_t box = { {0.0, 0.0}, 100, 200 };
	Point_t center = FindCenter (box);
	PrintPoint (center);
\end{verbatim}
%
The output of this program is {\tt (50, 100)}.

We could have passed the structure as a reference to the
function. In this case our function would look like this:

\begin{verbatim}
	Point_t FindCenter (Rectangle_t *box)
	{
		double x = box->corner.x + box->width/2;
		double y = box->corner.y + box->height/2;
		Point_t result = {x, y};
		return result;
	}
\end{verbatim}
Notice, how we had to change the access to the members of the 
structure, since {\tt box} is now a pointer. 
We would also have to change the function call for {\tt FindCenter()}:

\begin{verbatim}
	Point_t center = FindCenter (&box);
\end{verbatim}

\section {Passing other types by reference}
\index{parameter passing}
\index{call by reference}
\index{reference}

It's not just structures that can be passed by reference.
All the other types we've seen can, too.  For example, to swap
two integers, we could write something like:

\begin{verbatim}
	void Swap (int *x, int *y)
	{
		int temp = *x;
		*x = *y;
		*y = temp;
	}
\end{verbatim}
%
We would call this function in the usual way:

\begin{verbatim}
	int i = 7;
	int j = 9;
	printf (" i=%i, j=%i\n", i, j);
	Swap (&i, &j);
	printf (" i=%i, j=%i\n", i, j);
\end{verbatim}
%
The output of this program shows that the variable
values have been swapped.  Draw a stack
diagram for this program to convince yourself this is true.
If the parameters {\tt x} and {\tt y} were declared as
regular integer variables (without the {\tt \*}s), {\tt Swap()} would
not work.  It would modify {\tt x} and {\tt y} and have no
effect on {\tt i} and {\tt j}.

When people start passing things like integers by reference,
they often try to use an expression
as a reference argument.  For example:

\begin{verbatim}
	int i = 7;
	int j = 9;
	Swap (&i, &j+1);         /* WRONG!! */
\end{verbatim}
%
Presumably the programmer wanted to increase the value of {\tt j} by {\tt 1}
before it is passed to the function.
This does not work as expected, because the expression {\tt j+1} now
is interpreted a pointer value and in now pointing to a memory
location beyond the variable {\tt j}. 
It is a little tricky to figure out exactly
what kinds of expressions make sense to be passed by reference.  For now
a good rule of thumb is that reference arguments have to be
variables.


\section{Glossary}

\begin{description}
	
	\item[structure:]  A collection of data grouped together and
	treated as a single object.
	
	\item[member variable:]  One of the named pieces of data that make up
	a structure.
	
	\item[reference:]  A value that indicates or refers to a variable
	or structure.  In a state diagram, a reference appears as an arrow.
	
	\item[pass by value:]  A method of parameter-passing in which the
	value provided as an argument is copied into the corresponding
	parameter, but the parameter and the argument occupy distinct
	locations.
	
	\item[pass by reference:]  A method of parameter-passing in which
	the parameter is a reference to the argument variable.  Changes
	to the parameter also affect the argument variable.
	
	\index{structure}
	\index{member variable}
	\index{reference}
	\index{pass by value}
	\index{pass by reference}
	
\end{description}

\section{Exercises}
\setcounter{exercisenum}{0}

\input{exercises/Exercise_9_english}


